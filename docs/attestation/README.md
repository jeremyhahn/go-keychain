# Key Attestation Guide

## Overview

Key attestation is a cryptographic mechanism that proves a key was generated in hardware (TPM, HSM) and never left the secure boundary. This is critical for zero-trust security architectures and regulatory compliance.

## What is Key Attestation?

Key attestation creates cryptographic evidence that:
1. **A key was generated in hardware** - not created in software
2. **The hardware signed the attestation** - with its attestation key
3. **The hardware is authentic** - verified via certificate chain
4. **The attestation is fresh** - includes timestamp and optional nonce

## Use Cases

### 1. Zero-Trust Architecture
Prove that cryptographic keys are truly hardware-backed before allowing sensitive operations:
```go
// Only trust the key if we can prove it's hardware-backed
stmt, err := backend.AttestKey(keyAttrs, nonce)
verifier.Verify(stmt, opts)
// Key is proven hardware-backed
```

### 2. Supply Chain Security
Validate that HSM devices contain authentic keys from trusted manufacturers:
```go
// Verify device identity certificate in attestation
// Ensure key was generated by authentic, uncompromised hardware
attestStmt.CertificateChain  // Device identity proof
attestStmt.Backend           // Which hardware generated the key
```

### 3. Compliance Requirements
Support FIPS 140-2, Common Criteria, and other security standards:
```go
// Standards require proof of hardware-backed keys
// Attestation provides this proof with:
// - Signature from hardware attestation key
// - Certificate chain to trusted root
// - Generation timestamp
```

### 4. Remote Attestation
Prove key provenance to remote systems without exposing key material:
```go
stmt, _ := backend.AttestKey(keyAttrs, nonce)
// Send attestation to remote system
// Remote system verifies without seeing the private key
remoteVerifier.Verify(stmt, opts)
```

## Supported Hardware

### TPM 2.0
- Uses TPM2_Certify command for attestation
- Includes PCR values for measured boot
- Supports RSA and ECDSA keys
- Access via `/dev/tpm0` or simulator

### PKCS#11 HSM
- Thales nShield
- YubiKey HSM
- SmartCard-HSM
- Gemalto/SafeNet devices
- SoftHSM (for testing)

## Architecture

### Attestation Components

1. **AttestationStatement** - The complete attestation proof
   - Signature from hardware attestation key
   - Certificate chain proving authenticity
   - Attested public key material
   - Format-specific evidence (TPM2_Certify output, HSM data)
   - Optional PCR values and nonce

2. **Verifier** - Validates attestation statements
   - Certificate chain validation
   - Signature verification
   - Freshness checking (timestamp, nonce)
   - PCR value validation

3. **VerifyOptions** - Configuration for verification
   - Trusted root certificates
   - Freshness window
   - Nonce checking
   - PCR validation

## API Usage

### Generating an Attestation

```go
import (
    "github.com/jeremyhahn/go-keychain/pkg/types"
    "github.com/jeremyhahn/go-keychain/pkg/tpm2"
)

// Initialize hardware backend
config := &tpm2.Config{
    DevicePath: "/dev/tpm0",
    SRKHandle:  0x81000001,
}
backend, _ := tpm2.NewTPM2KeyStore(config, nil, keyStorage, certStorage, nil)
backend.Initialize(soPIN, userPIN)
defer backend.Close()

// Generate key
keyAttrs := &types.KeyAttributes{
    CN:               "my-signing-key",
    KeyAlgorithm:     x509.ECDSA,
    SignatureAlgorithm: x509.ECDSAWithSHA256,
    KeyType:          types.KeyTypeSigning,
    StoreType:        types.StoreTPM2,
    ECCAttributes: &types.ECCAttributes{
        Curve: elliptic.P256(),
    },
}
privKey, _ := backend.GenerateKey(keyAttrs)

// Attest the key
nonce := make([]byte, 8)
rand.Read(nonce)

// backend must implement AttestingBackend interface
attestBackend := backend.(types.AttestingBackend)
stmt, _ := attestBackend.AttestKey(keyAttrs, nonce)
attestStmt := stmt.(*attestation.AttestationStatement)
```

### Verifying an Attestation

```go
import "github.com/jeremyhahn/go-keychain/pkg/attestation"

// Create verifier with trusted roots
trustedRoots := loadTrustedRoots()
verifier := attestation.NewVerifier(trustedRoots)

// Verify with secure options (production recommended)
opts := attestation.DefaultVerifyOptions()
opts.ExpectedNonce = nonce  // Validate against expected nonce
opts.FreshnessWindow = 300  // 5 minute window

err := verifier.Verify(attestStmt, opts)
if err != nil {
    log.Fatal("Attestation verification failed:", err)
}

// Attestation is valid - key is proven hardware-backed
fmt.Println("Key attestation verified")
```

### TPM2-Specific: PCR Validation

```go
// Verify TPM PCR values as part of attestation
opts := attestation.DefaultVerifyOptions()
opts.VerifyPCRs = true
opts.ExpectedPCRs = map[uint32][]byte{
    0:  expectedPCR0Digest,  // BIOS PCR
    7:  expectedPCR7Digest,  // Secure Boot state
    11: expectedPCR11Digest, // OS measurement
}

err := verifier.Verify(attestStmt, opts)
// If successful, PCRs match expected state
```

## Security Considerations

### 1. Nonce Freshness
Always use nonces to prevent replay attacks:
```go
// Generate random nonce
nonce := make([]byte, 16)
rand.Read(nonce)

// Include in attestation request
stmt, _ := backend.AttestKey(keyAttrs, nonce)

// Verify nonce matches
opts := attestation.DefaultVerifyOptions()
opts.ExpectedNonce = nonce
verifier.Verify(stmt, opts)  // Fails if nonce doesn't match
```

### 2. Certificate Chain Validation
Always verify the complete certificate chain:
```go
opts := attestation.DefaultVerifyOptions()
opts.TrustedRoots = loadManufacturerCertificates()
opts.AllowSelfSigned = false  // Require chain to trusted root

err := verifier.Verify(stmt, opts)
// Verification fails unless chain reaches trusted root
```

### 3. Freshness Checking
Prevent use of old attestations (potential replays):
```go
opts := attestation.DefaultVerifyOptions()
opts.CheckFreshness = true
opts.FreshnessWindow = 300  // 5 minutes - typical value
opts.CurrentTime = currentTime  // For testing/auditing

err := verifier.Verify(stmt, opts)
// Fails if attestation is older than freshness window
```

### 4. Certificate Expiration
Validate certificate timestamps:
```go
// VerifyChain checks:
// - NotBefore and NotAfter dates
// - Full chain validity
// - Usage constraints
verifier.VerifyChain(stmt, opts)
```

## Attestation Formats

### TPM 2.0 Format
```go
stmt.Format = "tpm2"
stmt.SignatureAlgorithm = x509.SHA256WithRSA
stmt.AttestationData = tpm2CertifyOutput
stmt.PCRValues = map[uint32][]byte{...}  // Platform measurements
```

### PKCS#11 Format
```go
stmt.Format = "pkcs11"
stmt.SignatureAlgorithm = x509.SHA256WithRSA
stmt.AttestationData = hsmAttestationData
stmt.ClaimData = map[string][]byte{
    "hsm_model": []byte("YubiKey"),
    "key_cn": []byte("my-key"),
}
```

## Testing and Development

### Using SoftHSM for Testing
SoftHSM is a software implementation of PKCS#11 for testing:
```bash
# Install SoftHSM
apt-get install softhsm2

# Initialize token
softhsm2-util --init-token --slot 0 --label "test-token" --pin 1234

# Use in code
config := &pkcs11.Config{
    LibraryPath: "/usr/lib/softhsm/libsofthsm2.so",
    TokenLabel: "test-token",
    UserPIN: "1234",
}
```

### Using TPM Simulator for Testing
```go
// Use google/go-tpm-tools simulator
simulator := &simulator.Simulator{}
tpmDevice, _ := simulator.GetTransport()

// Use with TPM2 backend
backend, _ := tpm2.NewTPM2KeyStore(config, nil, storage, certs, tpmDevice)
```

### Insecure Verification (Lab Only)
```go
// For testing without proper certificate infrastructure
opts := attestation.InsecureVerifyOptions()
opts.AllowSelfSigned = true
opts.CheckFreshness = false

// WARNING: Never use in production
verifier.Verify(stmt, opts)
```

## Error Handling

```go
import "github.com/jeremyhahn/go-keychain/pkg/keychain"

stmt, err := backend.AttestKey(keyAttrs, nonce)
switch err {
case keychain.ErrNotSupported:
    // Hardware doesn't support attestation
    fmt.Println("This backend does not support key attestation")
case keychain.ErrNotFound:
    // Key doesn't exist
    fmt.Println("Key not found")
default:
    // Other errors (TPM errors, communication failures, etc)
    log.Fatal("Attestation failed:", err)
}

// Verification errors
opts := attestation.DefaultVerifyOptions()
err := verifier.Verify(stmt, opts)
switch err {
case fmt.Errorf("certificate expired"):
    // Handle expired certificates
case fmt.Errorf("signature verification failed"):
    // Handle signature failures (likely tampering)
case fmt.Errorf("too old"):
    // Attestation outside freshness window
default:
    // Other verification failures
}
```

## Integration with key Management

### Storing Attestations
```go
// Store attestation statement with key metadata
metadata := &KeyMetadata{
    CN: "my-key",
    AttestationStatement: attestStmt,
    AttestationTime: time.Now(),
    AttestationVerified: true,
}
keyStore.SaveMetadata(metadata)
```

### Periodic Re-attestation
```go
// Periodically re-attest keys for ongoing validation
ticker := time.NewTicker(24 * time.Hour)
for range ticker.C {
    stmt, _ := backend.AttestKey(keyAttrs, newNonce)
    opts := attestation.DefaultVerifyOptions()

    if err := verifier.Verify(stmt, opts); err != nil {
        log.Printf("Key attestation verification failed: %v", err)
        // Alert - key may be compromised
    }
}
```

## Performance Considerations

### Attestation Overhead
- TPM2_Certify: Typically 50-200ms per key
- PKCS#11 signing: Depends on HSM (usually < 100ms)
- Verification: Typically < 50ms for signature and chain validation

### Optimization
```go
// Batch attestations if attesting multiple keys
for _, keyAttrs := range allKeys {
    stmt, _ := backend.AttestKey(keyAttrs, nonce)
    stmts = append(stmts, stmt)
}
```

## References

- [TPM 2.0 Specification](https://trustedcomputinggroup.org/)
- [PKCS#11 Specification](http://docs.oasis-open.org/pkcs11/pkcs11-base/)
- [FIPS 140-2 Requirements](https://csrc.nist.gov/publications/fips/fips-140-2/)
- [go-tpm Library](https://github.com/google/go-tpm)
- [crypto11 Library](https://github.com/ThalesGroup/crypto11)

## Support and Issues

For questions or issues with key attestation:
- Check the examples in `examples/attestation/`
- Review test cases in `pkg/attestation/*_test.go`
- Report issues on GitHub with attestation-related details
