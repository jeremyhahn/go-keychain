// Copyright (c) 2025 Jeremy Hahn
// Copyright (c) 2025 Automate The Things, LLC
//
// This file is part of go-keychain.
//
// go-keychain is dual-licensed:
//
// 1. GNU Affero General Public License v3.0 (AGPL-3.0)
//    See LICENSE file or visit https://www.gnu.org/licenses/agpl-3.0.html
//
// 2. Commercial License
//    Contact licensing@automatethethings.com for commercial licensing options.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: keychain.proto
package keychainv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	KeystoreService_Health_FullMethodName              = "/keychain.v1.KeystoreService/Health"
	KeystoreService_ListBackends_FullMethodName        = "/keychain.v1.KeystoreService/ListBackends"
	KeystoreService_GetBackendInfo_FullMethodName      = "/keychain.v1.KeystoreService/GetBackendInfo"
	KeystoreService_GenerateKey_FullMethodName         = "/keychain.v1.KeystoreService/GenerateKey"
	KeystoreService_ListKeys_FullMethodName            = "/keychain.v1.KeystoreService/ListKeys"
	KeystoreService_GetKey_FullMethodName              = "/keychain.v1.KeystoreService/GetKey"
	KeystoreService_Sign_FullMethodName                = "/keychain.v1.KeystoreService/Sign"
	KeystoreService_Verify_FullMethodName              = "/keychain.v1.KeystoreService/Verify"
	KeystoreService_DeleteKey_FullMethodName           = "/keychain.v1.KeystoreService/DeleteKey"
	KeystoreService_RotateKey_FullMethodName           = "/keychain.v1.KeystoreService/RotateKey"
	KeystoreService_Encrypt_FullMethodName             = "/keychain.v1.KeystoreService/Encrypt"
	KeystoreService_Decrypt_FullMethodName             = "/keychain.v1.KeystoreService/Decrypt"
	KeystoreService_SaveCert_FullMethodName            = "/keychain.v1.KeystoreService/SaveCert"
	KeystoreService_GetCert_FullMethodName             = "/keychain.v1.KeystoreService/GetCert"
	KeystoreService_DeleteCert_FullMethodName          = "/keychain.v1.KeystoreService/DeleteCert"
	KeystoreService_ListCerts_FullMethodName           = "/keychain.v1.KeystoreService/ListCerts"
	KeystoreService_CertExists_FullMethodName          = "/keychain.v1.KeystoreService/CertExists"
	KeystoreService_SaveCertChain_FullMethodName       = "/keychain.v1.KeystoreService/SaveCertChain"
	KeystoreService_GetCertChain_FullMethodName        = "/keychain.v1.KeystoreService/GetCertChain"
	KeystoreService_GetTLSCertificate_FullMethodName   = "/keychain.v1.KeystoreService/GetTLSCertificate"
	KeystoreService_GetImportParameters_FullMethodName = "/keychain.v1.KeystoreService/GetImportParameters"
	KeystoreService_WrapKey_FullMethodName             = "/keychain.v1.KeystoreService/WrapKey"
	KeystoreService_UnwrapKey_FullMethodName           = "/keychain.v1.KeystoreService/UnwrapKey"
	KeystoreService_ImportKey_FullMethodName           = "/keychain.v1.KeystoreService/ImportKey"
	KeystoreService_ExportKey_FullMethodName           = "/keychain.v1.KeystoreService/ExportKey"
	KeystoreService_CopyKey_FullMethodName             = "/keychain.v1.KeystoreService/CopyKey"
)

// KeystoreServiceClient is the client API for KeystoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// KeystoreService provides key management and cryptographic operations
type KeystoreServiceClient interface {
	// Health returns the health status of the service
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	// ListBackends returns all available backend providers
	ListBackends(ctx context.Context, in *ListBackendsRequest, opts ...grpc.CallOption) (*ListBackendsResponse, error)
	// GetBackendInfo returns detailed information about a specific backend
	GetBackendInfo(ctx context.Context, in *GetBackendInfoRequest, opts ...grpc.CallOption) (*GetBackendInfoResponse, error)
	// GenerateKey generates a new cryptographic key
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error)
	// ListKeys lists all keys in the specified backend
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error)
	// GetKey retrieves information about a specific key
	GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error)
	// Sign signs data with the specified key
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	// Verify verifies a signature with the specified key
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	// DeleteKey deletes a key from the backend
	DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*DeleteKeyResponse, error)
	// RotateKey rotates an existing key
	RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error)
	// Encrypt encrypts data with the specified key (symmetric encryption)
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	// Decrypt decrypts data with the specified key
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	// SaveCert stores a certificate
	SaveCert(ctx context.Context, in *SaveCertRequest, opts ...grpc.CallOption) (*SaveCertResponse, error)
	// GetCert retrieves a certificate
	GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error)
	// DeleteCert removes a certificate
	DeleteCert(ctx context.Context, in *DeleteCertRequest, opts ...grpc.CallOption) (*DeleteCertResponse, error)
	// ListCerts lists all certificates
	ListCerts(ctx context.Context, in *ListCertsRequest, opts ...grpc.CallOption) (*ListCertsResponse, error)
	// CertExists checks if a certificate exists
	CertExists(ctx context.Context, in *CertExistsRequest, opts ...grpc.CallOption) (*CertExistsResponse, error)
	// SaveCertChain stores a certificate chain
	SaveCertChain(ctx context.Context, in *SaveCertChainRequest, opts ...grpc.CallOption) (*SaveCertChainResponse, error)
	// GetCertChain retrieves a certificate chain
	GetCertChain(ctx context.Context, in *GetCertChainRequest, opts ...grpc.CallOption) (*GetCertChainResponse, error)
	// GetTLSCertificate returns a TLS certificate with private key
	GetTLSCertificate(ctx context.Context, in *GetTLSCertificateRequest, opts ...grpc.CallOption) (*GetTLSCertificateResponse, error)
	// GetImportParameters retrieves parameters needed to import a key
	GetImportParameters(ctx context.Context, in *GetImportParametersRequest, opts ...grpc.CallOption) (*GetImportParametersResponse, error)
	// WrapKey wraps key material for secure transport
	WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error)
	// UnwrapKey unwraps previously wrapped key material
	UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error)
	// ImportKey imports externally generated key material into the backend
	ImportKey(ctx context.Context, in *ImportKeyRequest, opts ...grpc.CallOption) (*ImportKeyResponse, error)
	// ExportKey exports a key in wrapped form for secure transport
	ExportKey(ctx context.Context, in *ExportKeyRequest, opts ...grpc.CallOption) (*ExportKeyResponse, error)
	// CopyKey copies a key from one backend to another
	CopyKey(ctx context.Context, in *CopyKeyRequest, opts ...grpc.CallOption) (*CopyKeyResponse, error)
}

type keystoreServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKeystoreServiceClient(cc grpc.ClientConnInterface) KeystoreServiceClient {
	return &keystoreServiceClient{cc}
}

func (c *keystoreServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ListBackends(ctx context.Context, in *ListBackendsRequest, opts ...grpc.CallOption) (*ListBackendsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBackendsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ListBackends_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetBackendInfo(ctx context.Context, in *GetBackendInfoRequest, opts ...grpc.CallOption) (*GetBackendInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackendInfoResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetBackendInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GenerateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeysResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ListKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Sign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Verify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*DeleteKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_DeleteKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RotateKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_RotateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Encrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Decrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) SaveCert(ctx context.Context, in *SaveCertRequest, opts ...grpc.CallOption) (*SaveCertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveCertResponse)
	err := c.cc.Invoke(ctx, KeystoreService_SaveCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCertResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) DeleteCert(ctx context.Context, in *DeleteCertRequest, opts ...grpc.CallOption) (*DeleteCertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCertResponse)
	err := c.cc.Invoke(ctx, KeystoreService_DeleteCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ListCerts(ctx context.Context, in *ListCertsRequest, opts ...grpc.CallOption) (*ListCertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCertsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ListCerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) CertExists(ctx context.Context, in *CertExistsRequest, opts ...grpc.CallOption) (*CertExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CertExistsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_CertExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) SaveCertChain(ctx context.Context, in *SaveCertChainRequest, opts ...grpc.CallOption) (*SaveCertChainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveCertChainResponse)
	err := c.cc.Invoke(ctx, KeystoreService_SaveCertChain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetCertChain(ctx context.Context, in *GetCertChainRequest, opts ...grpc.CallOption) (*GetCertChainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCertChainResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetCertChain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetTLSCertificate(ctx context.Context, in *GetTLSCertificateRequest, opts ...grpc.CallOption) (*GetTLSCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTLSCertificateResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetTLSCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetImportParameters(ctx context.Context, in *GetImportParametersRequest, opts ...grpc.CallOption) (*GetImportParametersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetImportParametersResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetImportParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WrapKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_WrapKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnwrapKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_UnwrapKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ImportKey(ctx context.Context, in *ImportKeyRequest, opts ...grpc.CallOption) (*ImportKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ImportKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ExportKey(ctx context.Context, in *ExportKeyRequest, opts ...grpc.CallOption) (*ExportKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ExportKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) CopyKey(ctx context.Context, in *CopyKeyRequest, opts ...grpc.CallOption) (*CopyKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CopyKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_CopyKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeystoreServiceServer is the server API for KeystoreService service.
// All implementations must embed UnimplementedKeystoreServiceServer
// for forward compatibility.
//
// KeystoreService provides key management and cryptographic operations
type KeystoreServiceServer interface {
	// Health returns the health status of the service
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	// ListBackends returns all available backend providers
	ListBackends(context.Context, *ListBackendsRequest) (*ListBackendsResponse, error)
	// GetBackendInfo returns detailed information about a specific backend
	GetBackendInfo(context.Context, *GetBackendInfoRequest) (*GetBackendInfoResponse, error)
	// GenerateKey generates a new cryptographic key
	GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error)
	// ListKeys lists all keys in the specified backend
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
	// GetKey retrieves information about a specific key
	GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error)
	// Sign signs data with the specified key
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	// Verify verifies a signature with the specified key
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	// DeleteKey deletes a key from the backend
	DeleteKey(context.Context, *DeleteKeyRequest) (*DeleteKeyResponse, error)
	// RotateKey rotates an existing key
	RotateKey(context.Context, *RotateKeyRequest) (*RotateKeyResponse, error)
	// Encrypt encrypts data with the specified key (symmetric encryption)
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	// Decrypt decrypts data with the specified key
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	// SaveCert stores a certificate
	SaveCert(context.Context, *SaveCertRequest) (*SaveCertResponse, error)
	// GetCert retrieves a certificate
	GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error)
	// DeleteCert removes a certificate
	DeleteCert(context.Context, *DeleteCertRequest) (*DeleteCertResponse, error)
	// ListCerts lists all certificates
	ListCerts(context.Context, *ListCertsRequest) (*ListCertsResponse, error)
	// CertExists checks if a certificate exists
	CertExists(context.Context, *CertExistsRequest) (*CertExistsResponse, error)
	// SaveCertChain stores a certificate chain
	SaveCertChain(context.Context, *SaveCertChainRequest) (*SaveCertChainResponse, error)
	// GetCertChain retrieves a certificate chain
	GetCertChain(context.Context, *GetCertChainRequest) (*GetCertChainResponse, error)
	// GetTLSCertificate returns a TLS certificate with private key
	GetTLSCertificate(context.Context, *GetTLSCertificateRequest) (*GetTLSCertificateResponse, error)
	// GetImportParameters retrieves parameters needed to import a key
	GetImportParameters(context.Context, *GetImportParametersRequest) (*GetImportParametersResponse, error)
	// WrapKey wraps key material for secure transport
	WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error)
	// UnwrapKey unwraps previously wrapped key material
	UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error)
	// ImportKey imports externally generated key material into the backend
	ImportKey(context.Context, *ImportKeyRequest) (*ImportKeyResponse, error)
	// ExportKey exports a key in wrapped form for secure transport
	ExportKey(context.Context, *ExportKeyRequest) (*ExportKeyResponse, error)
	// CopyKey copies a key from one backend to another
	CopyKey(context.Context, *CopyKeyRequest) (*CopyKeyResponse, error)
	mustEmbedUnimplementedKeystoreServiceServer()
}

// UnimplementedKeystoreServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKeystoreServiceServer struct{}

func (UnimplementedKeystoreServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedKeystoreServiceServer) ListBackends(context.Context, *ListBackendsRequest) (*ListBackendsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBackends not implemented")
}
func (UnimplementedKeystoreServiceServer) GetBackendInfo(context.Context, *GetBackendInfoRequest) (*GetBackendInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBackendInfo not implemented")
}
func (UnimplementedKeystoreServiceServer) GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateKey not implemented")
}
func (UnimplementedKeystoreServiceServer) ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKeys not implemented")
}
func (UnimplementedKeystoreServiceServer) GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}
func (UnimplementedKeystoreServiceServer) Sign(context.Context, *SignRequest) (*SignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedKeystoreServiceServer) Verify(context.Context, *VerifyRequest) (*VerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedKeystoreServiceServer) DeleteKey(context.Context, *DeleteKeyRequest) (*DeleteKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKey not implemented")
}
func (UnimplementedKeystoreServiceServer) RotateKey(context.Context, *RotateKeyRequest) (*RotateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateKey not implemented")
}
func (UnimplementedKeystoreServiceServer) Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedKeystoreServiceServer) Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedKeystoreServiceServer) SaveCert(context.Context, *SaveCertRequest) (*SaveCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveCert not implemented")
}
func (UnimplementedKeystoreServiceServer) GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCert not implemented")
}
func (UnimplementedKeystoreServiceServer) DeleteCert(context.Context, *DeleteCertRequest) (*DeleteCertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCert not implemented")
}
func (UnimplementedKeystoreServiceServer) ListCerts(context.Context, *ListCertsRequest) (*ListCertsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCerts not implemented")
}
func (UnimplementedKeystoreServiceServer) CertExists(context.Context, *CertExistsRequest) (*CertExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CertExists not implemented")
}
func (UnimplementedKeystoreServiceServer) SaveCertChain(context.Context, *SaveCertChainRequest) (*SaveCertChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveCertChain not implemented")
}
func (UnimplementedKeystoreServiceServer) GetCertChain(context.Context, *GetCertChainRequest) (*GetCertChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCertChain not implemented")
}
func (UnimplementedKeystoreServiceServer) GetTLSCertificate(context.Context, *GetTLSCertificateRequest) (*GetTLSCertificateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTLSCertificate not implemented")
}
func (UnimplementedKeystoreServiceServer) GetImportParameters(context.Context, *GetImportParametersRequest) (*GetImportParametersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImportParameters not implemented")
}
func (UnimplementedKeystoreServiceServer) WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WrapKey not implemented")
}
func (UnimplementedKeystoreServiceServer) UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnwrapKey not implemented")
}
func (UnimplementedKeystoreServiceServer) ImportKey(context.Context, *ImportKeyRequest) (*ImportKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportKey not implemented")
}
func (UnimplementedKeystoreServiceServer) ExportKey(context.Context, *ExportKeyRequest) (*ExportKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportKey not implemented")
}
func (UnimplementedKeystoreServiceServer) CopyKey(context.Context, *CopyKeyRequest) (*CopyKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyKey not implemented")
}
func (UnimplementedKeystoreServiceServer) mustEmbedUnimplementedKeystoreServiceServer() {}
func (UnimplementedKeystoreServiceServer) testEmbeddedByValue()                         {}

// UnsafeKeystoreServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeystoreServiceServer will
// result in compilation errors.
type UnsafeKeystoreServiceServer interface {
	mustEmbedUnimplementedKeystoreServiceServer()
}

func RegisterKeystoreServiceServer(s grpc.ServiceRegistrar, srv KeystoreServiceServer) {
	// If the following call pancis, it indicates UnimplementedKeystoreServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KeystoreService_ServiceDesc, srv)
}

func _KeystoreService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ListBackends_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackendsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ListBackends(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ListBackends_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ListBackends(ctx, req.(*ListBackendsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetBackendInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackendInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetBackendInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetBackendInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetBackendInfo(ctx, req.(*GetBackendInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GenerateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ListKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ListKeys(ctx, req.(*ListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Sign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).DeleteKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_DeleteKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).DeleteKey(ctx, req.(*DeleteKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_RotateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).RotateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_RotateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).RotateKey(ctx, req.(*RotateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Encrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Decrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_SaveCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).SaveCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_SaveCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).SaveCert(ctx, req.(*SaveCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetCert(ctx, req.(*GetCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_DeleteCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).DeleteCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_DeleteCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).DeleteCert(ctx, req.(*DeleteCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ListCerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ListCerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ListCerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ListCerts(ctx, req.(*ListCertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_CertExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).CertExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_CertExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).CertExists(ctx, req.(*CertExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_SaveCertChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveCertChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).SaveCertChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_SaveCertChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).SaveCertChain(ctx, req.(*SaveCertChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetCertChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetCertChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetCertChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetCertChain(ctx, req.(*GetCertChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetTLSCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTLSCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetTLSCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetTLSCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetTLSCertificate(ctx, req.(*GetTLSCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetImportParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImportParametersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetImportParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetImportParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetImportParameters(ctx, req.(*GetImportParametersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_WrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).WrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_WrapKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).WrapKey(ctx, req.(*WrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_UnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).UnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_UnwrapKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).UnwrapKey(ctx, req.(*UnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ImportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ImportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ImportKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ImportKey(ctx, req.(*ImportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ExportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ExportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ExportKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ExportKey(ctx, req.(*ExportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_CopyKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).CopyKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_CopyKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).CopyKey(ctx, req.(*CopyKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeystoreService_ServiceDesc is the grpc.ServiceDesc for KeystoreService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeystoreService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "keychain.v1.KeystoreService",
	HandlerType: (*KeystoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Health",
			Handler:    _KeystoreService_Health_Handler,
		},
		{
			MethodName: "ListBackends",
			Handler:    _KeystoreService_ListBackends_Handler,
		},
		{
			MethodName: "GetBackendInfo",
			Handler:    _KeystoreService_GetBackendInfo_Handler,
		},
		{
			MethodName: "GenerateKey",
			Handler:    _KeystoreService_GenerateKey_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _KeystoreService_ListKeys_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _KeystoreService_GetKey_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _KeystoreService_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _KeystoreService_Verify_Handler,
		},
		{
			MethodName: "DeleteKey",
			Handler:    _KeystoreService_DeleteKey_Handler,
		},
		{
			MethodName: "RotateKey",
			Handler:    _KeystoreService_RotateKey_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _KeystoreService_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _KeystoreService_Decrypt_Handler,
		},
		{
			MethodName: "SaveCert",
			Handler:    _KeystoreService_SaveCert_Handler,
		},
		{
			MethodName: "GetCert",
			Handler:    _KeystoreService_GetCert_Handler,
		},
		{
			MethodName: "DeleteCert",
			Handler:    _KeystoreService_DeleteCert_Handler,
		},
		{
			MethodName: "ListCerts",
			Handler:    _KeystoreService_ListCerts_Handler,
		},
		{
			MethodName: "CertExists",
			Handler:    _KeystoreService_CertExists_Handler,
		},
		{
			MethodName: "SaveCertChain",
			Handler:    _KeystoreService_SaveCertChain_Handler,
		},
		{
			MethodName: "GetCertChain",
			Handler:    _KeystoreService_GetCertChain_Handler,
		},
		{
			MethodName: "GetTLSCertificate",
			Handler:    _KeystoreService_GetTLSCertificate_Handler,
		},
		{
			MethodName: "GetImportParameters",
			Handler:    _KeystoreService_GetImportParameters_Handler,
		},
		{
			MethodName: "WrapKey",
			Handler:    _KeystoreService_WrapKey_Handler,
		},
		{
			MethodName: "UnwrapKey",
			Handler:    _KeystoreService_UnwrapKey_Handler,
		},
		{
			MethodName: "ImportKey",
			Handler:    _KeystoreService_ImportKey_Handler,
		},
		{
			MethodName: "ExportKey",
			Handler:    _KeystoreService_ExportKey_Handler,
		},
		{
			MethodName: "CopyKey",
			Handler:    _KeystoreService_CopyKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "keychain.proto",
}
