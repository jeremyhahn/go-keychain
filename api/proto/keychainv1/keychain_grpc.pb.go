// Copyright (c) 2025 Jeremy Hahn
// SPDX-License-Identifier: AGPL-3.0

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: api/proto/keychainv1/keychain.proto

package keychainv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	KeystoreService_Health_FullMethodName                = "/keychain.v1.KeystoreService/Health"
	KeystoreService_ListBackends_FullMethodName          = "/keychain.v1.KeystoreService/ListBackends"
	KeystoreService_GetBackendInfo_FullMethodName        = "/keychain.v1.KeystoreService/GetBackendInfo"
	KeystoreService_GenerateKey_FullMethodName           = "/keychain.v1.KeystoreService/GenerateKey"
	KeystoreService_ListKeys_FullMethodName              = "/keychain.v1.KeystoreService/ListKeys"
	KeystoreService_GetKey_FullMethodName                = "/keychain.v1.KeystoreService/GetKey"
	KeystoreService_Sign_FullMethodName                  = "/keychain.v1.KeystoreService/Sign"
	KeystoreService_Verify_FullMethodName                = "/keychain.v1.KeystoreService/Verify"
	KeystoreService_DeleteKey_FullMethodName             = "/keychain.v1.KeystoreService/DeleteKey"
	KeystoreService_RotateKey_FullMethodName             = "/keychain.v1.KeystoreService/RotateKey"
	KeystoreService_ListKeyVersions_FullMethodName       = "/keychain.v1.KeystoreService/ListKeyVersions"
	KeystoreService_EnableKeyVersion_FullMethodName      = "/keychain.v1.KeystoreService/EnableKeyVersion"
	KeystoreService_DisableKeyVersion_FullMethodName     = "/keychain.v1.KeystoreService/DisableKeyVersion"
	KeystoreService_EnableAllKeyVersions_FullMethodName  = "/keychain.v1.KeystoreService/EnableAllKeyVersions"
	KeystoreService_DisableAllKeyVersions_FullMethodName = "/keychain.v1.KeystoreService/DisableAllKeyVersions"
	KeystoreService_Encrypt_FullMethodName               = "/keychain.v1.KeystoreService/Encrypt"
	KeystoreService_Decrypt_FullMethodName               = "/keychain.v1.KeystoreService/Decrypt"
	KeystoreService_EncryptAsym_FullMethodName           = "/keychain.v1.KeystoreService/EncryptAsym"
	KeystoreService_SaveCert_FullMethodName              = "/keychain.v1.KeystoreService/SaveCert"
	KeystoreService_GetCert_FullMethodName               = "/keychain.v1.KeystoreService/GetCert"
	KeystoreService_DeleteCert_FullMethodName            = "/keychain.v1.KeystoreService/DeleteCert"
	KeystoreService_ListCerts_FullMethodName             = "/keychain.v1.KeystoreService/ListCerts"
	KeystoreService_CertExists_FullMethodName            = "/keychain.v1.KeystoreService/CertExists"
	KeystoreService_SaveCertChain_FullMethodName         = "/keychain.v1.KeystoreService/SaveCertChain"
	KeystoreService_GetCertChain_FullMethodName          = "/keychain.v1.KeystoreService/GetCertChain"
	KeystoreService_GetTLSCertificate_FullMethodName     = "/keychain.v1.KeystoreService/GetTLSCertificate"
	KeystoreService_GetImportParameters_FullMethodName   = "/keychain.v1.KeystoreService/GetImportParameters"
	KeystoreService_WrapKey_FullMethodName               = "/keychain.v1.KeystoreService/WrapKey"
	KeystoreService_UnwrapKey_FullMethodName             = "/keychain.v1.KeystoreService/UnwrapKey"
	KeystoreService_ImportKey_FullMethodName             = "/keychain.v1.KeystoreService/ImportKey"
	KeystoreService_ExportKey_FullMethodName             = "/keychain.v1.KeystoreService/ExportKey"
	KeystoreService_CopyKey_FullMethodName               = "/keychain.v1.KeystoreService/CopyKey"
	KeystoreService_FrostGenerateKey_FullMethodName      = "/keychain.v1.KeystoreService/FrostGenerateKey"
	KeystoreService_FrostImportKey_FullMethodName        = "/keychain.v1.KeystoreService/FrostImportKey"
	KeystoreService_FrostListKeys_FullMethodName         = "/keychain.v1.KeystoreService/FrostListKeys"
	KeystoreService_FrostGetKey_FullMethodName           = "/keychain.v1.KeystoreService/FrostGetKey"
	KeystoreService_FrostDeleteKey_FullMethodName        = "/keychain.v1.KeystoreService/FrostDeleteKey"
	KeystoreService_FrostGenerateNonces_FullMethodName   = "/keychain.v1.KeystoreService/FrostGenerateNonces"
	KeystoreService_FrostSignRound_FullMethodName        = "/keychain.v1.KeystoreService/FrostSignRound"
	KeystoreService_FrostAggregate_FullMethodName        = "/keychain.v1.KeystoreService/FrostAggregate"
	KeystoreService_FrostVerify_FullMethodName           = "/keychain.v1.KeystoreService/FrostVerify"
)

// KeystoreServiceClient is the client API for KeystoreService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// KeystoreService provides key management and cryptographic operations
type KeystoreServiceClient interface {
	// Health returns the health status of the service
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	// ListBackends returns all available backend providers
	ListBackends(ctx context.Context, in *ListBackendsRequest, opts ...grpc.CallOption) (*ListBackendsResponse, error)
	// GetBackendInfo returns detailed information about a specific backend
	GetBackendInfo(ctx context.Context, in *GetBackendInfoRequest, opts ...grpc.CallOption) (*GetBackendInfoResponse, error)
	// GenerateKey generates a new cryptographic key
	GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error)
	// ListKeys lists all keys in the specified backend
	ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error)
	// GetKey retrieves information about a specific key
	GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error)
	// Sign signs data with the specified key
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	// Verify verifies a signature with the specified key
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	// DeleteKey deletes a key from the backend
	DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*DeleteKeyResponse, error)
	// RotateKey rotates an existing key
	RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error)
	// ListKeyVersions lists all versions of a key
	ListKeyVersions(ctx context.Context, in *ListKeyVersionsRequest, opts ...grpc.CallOption) (*ListKeyVersionsResponse, error)
	// EnableKeyVersion enables a specific version of a key
	EnableKeyVersion(ctx context.Context, in *EnableKeyVersionRequest, opts ...grpc.CallOption) (*EnableKeyVersionResponse, error)
	// DisableKeyVersion disables a specific version of a key
	DisableKeyVersion(ctx context.Context, in *DisableKeyVersionRequest, opts ...grpc.CallOption) (*DisableKeyVersionResponse, error)
	// EnableAllKeyVersions enables all versions of a key
	EnableAllKeyVersions(ctx context.Context, in *EnableAllKeyVersionsRequest, opts ...grpc.CallOption) (*EnableAllKeyVersionsResponse, error)
	// DisableAllKeyVersions disables all versions of a key
	DisableAllKeyVersions(ctx context.Context, in *DisableAllKeyVersionsRequest, opts ...grpc.CallOption) (*DisableAllKeyVersionsResponse, error)
	// Encrypt encrypts data with the specified key (symmetric encryption)
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	// Decrypt decrypts data with the specified key
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	// EncryptAsym encrypts data using asymmetric encryption (RSA-OAEP)
	EncryptAsym(ctx context.Context, in *EncryptAsymRequest, opts ...grpc.CallOption) (*EncryptAsymResponse, error)
	// SaveCert stores a certificate
	SaveCert(ctx context.Context, in *SaveCertRequest, opts ...grpc.CallOption) (*SaveCertResponse, error)
	// GetCert retrieves a certificate
	GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error)
	// DeleteCert removes a certificate
	DeleteCert(ctx context.Context, in *DeleteCertRequest, opts ...grpc.CallOption) (*DeleteCertResponse, error)
	// ListCerts lists all certificates
	ListCerts(ctx context.Context, in *ListCertsRequest, opts ...grpc.CallOption) (*ListCertsResponse, error)
	// CertExists checks if a certificate exists
	CertExists(ctx context.Context, in *CertExistsRequest, opts ...grpc.CallOption) (*CertExistsResponse, error)
	// SaveCertChain stores a certificate chain
	SaveCertChain(ctx context.Context, in *SaveCertChainRequest, opts ...grpc.CallOption) (*SaveCertChainResponse, error)
	// GetCertChain retrieves a certificate chain
	GetCertChain(ctx context.Context, in *GetCertChainRequest, opts ...grpc.CallOption) (*GetCertChainResponse, error)
	// GetTLSCertificate returns a TLS certificate with private key
	GetTLSCertificate(ctx context.Context, in *GetTLSCertificateRequest, opts ...grpc.CallOption) (*GetTLSCertificateResponse, error)
	// GetImportParameters retrieves parameters needed to import a key
	GetImportParameters(ctx context.Context, in *GetImportParametersRequest, opts ...grpc.CallOption) (*GetImportParametersResponse, error)
	// WrapKey wraps key material for secure transport
	WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error)
	// UnwrapKey unwraps previously wrapped key material
	UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error)
	// ImportKey imports externally generated key material into the backend
	ImportKey(ctx context.Context, in *ImportKeyRequest, opts ...grpc.CallOption) (*ImportKeyResponse, error)
	// ExportKey exports a key in wrapped form for secure transport
	ExportKey(ctx context.Context, in *ExportKeyRequest, opts ...grpc.CallOption) (*ExportKeyResponse, error)
	// CopyKey copies a key from one backend to another
	CopyKey(ctx context.Context, in *CopyKeyRequest, opts ...grpc.CallOption) (*CopyKeyResponse, error)
	// FrostGenerateKey generates FROST key packages using trusted dealer model
	FrostGenerateKey(ctx context.Context, in *FrostGenerateKeyRequest, opts ...grpc.CallOption) (*FrostGenerateKeyResponse, error)
	// FrostImportKey imports a FROST key package
	FrostImportKey(ctx context.Context, in *FrostImportKeyRequest, opts ...grpc.CallOption) (*FrostImportKeyResponse, error)
	// FrostListKeys lists all FROST keys
	FrostListKeys(ctx context.Context, in *FrostListKeysRequest, opts ...grpc.CallOption) (*FrostListKeysResponse, error)
	// FrostGetKey retrieves information about a specific FROST key
	FrostGetKey(ctx context.Context, in *FrostGetKeyRequest, opts ...grpc.CallOption) (*FrostGetKeyResponse, error)
	// FrostDeleteKey deletes a FROST key
	FrostDeleteKey(ctx context.Context, in *FrostDeleteKeyRequest, opts ...grpc.CallOption) (*FrostDeleteKeyResponse, error)
	// FrostGenerateNonces generates nonces and commitments for Round 1 of FROST signing
	FrostGenerateNonces(ctx context.Context, in *FrostGenerateNoncesRequest, opts ...grpc.CallOption) (*FrostGenerateNoncesResponse, error)
	// FrostSignRound generates a signature share for Round 2 of FROST signing
	FrostSignRound(ctx context.Context, in *FrostSignRoundRequest, opts ...grpc.CallOption) (*FrostSignRoundResponse, error)
	// FrostAggregate combines signature shares into a final FROST signature
	FrostAggregate(ctx context.Context, in *FrostAggregateRequest, opts ...grpc.CallOption) (*FrostAggregateResponse, error)
	// FrostVerify verifies a FROST signature against the group public key
	FrostVerify(ctx context.Context, in *FrostVerifyRequest, opts ...grpc.CallOption) (*FrostVerifyResponse, error)
}

type keystoreServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKeystoreServiceClient(cc grpc.ClientConnInterface) KeystoreServiceClient {
	return &keystoreServiceClient{cc}
}

func (c *keystoreServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ListBackends(ctx context.Context, in *ListBackendsRequest, opts ...grpc.CallOption) (*ListBackendsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBackendsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ListBackends_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetBackendInfo(ctx context.Context, in *GetBackendInfoRequest, opts ...grpc.CallOption) (*GetBackendInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetBackendInfoResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetBackendInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GenerateKey(ctx context.Context, in *GenerateKeyRequest, opts ...grpc.CallOption) (*GenerateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GenerateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...grpc.CallOption) (*ListKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeysResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ListKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Sign_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Verify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...grpc.CallOption) (*DeleteKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_DeleteKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) RotateKey(ctx context.Context, in *RotateKeyRequest, opts ...grpc.CallOption) (*RotateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RotateKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_RotateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ListKeyVersions(ctx context.Context, in *ListKeyVersionsRequest, opts ...grpc.CallOption) (*ListKeyVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListKeyVersionsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ListKeyVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) EnableKeyVersion(ctx context.Context, in *EnableKeyVersionRequest, opts ...grpc.CallOption) (*EnableKeyVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableKeyVersionResponse)
	err := c.cc.Invoke(ctx, KeystoreService_EnableKeyVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) DisableKeyVersion(ctx context.Context, in *DisableKeyVersionRequest, opts ...grpc.CallOption) (*DisableKeyVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableKeyVersionResponse)
	err := c.cc.Invoke(ctx, KeystoreService_DisableKeyVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) EnableAllKeyVersions(ctx context.Context, in *EnableAllKeyVersionsRequest, opts ...grpc.CallOption) (*EnableAllKeyVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableAllKeyVersionsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_EnableAllKeyVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) DisableAllKeyVersions(ctx context.Context, in *DisableAllKeyVersionsRequest, opts ...grpc.CallOption) (*DisableAllKeyVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableAllKeyVersionsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_DisableAllKeyVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Encrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, KeystoreService_Decrypt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) EncryptAsym(ctx context.Context, in *EncryptAsymRequest, opts ...grpc.CallOption) (*EncryptAsymResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EncryptAsymResponse)
	err := c.cc.Invoke(ctx, KeystoreService_EncryptAsym_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) SaveCert(ctx context.Context, in *SaveCertRequest, opts ...grpc.CallOption) (*SaveCertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveCertResponse)
	err := c.cc.Invoke(ctx, KeystoreService_SaveCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetCert(ctx context.Context, in *GetCertRequest, opts ...grpc.CallOption) (*GetCertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCertResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) DeleteCert(ctx context.Context, in *DeleteCertRequest, opts ...grpc.CallOption) (*DeleteCertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCertResponse)
	err := c.cc.Invoke(ctx, KeystoreService_DeleteCert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ListCerts(ctx context.Context, in *ListCertsRequest, opts ...grpc.CallOption) (*ListCertsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCertsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ListCerts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) CertExists(ctx context.Context, in *CertExistsRequest, opts ...grpc.CallOption) (*CertExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CertExistsResponse)
	err := c.cc.Invoke(ctx, KeystoreService_CertExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) SaveCertChain(ctx context.Context, in *SaveCertChainRequest, opts ...grpc.CallOption) (*SaveCertChainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveCertChainResponse)
	err := c.cc.Invoke(ctx, KeystoreService_SaveCertChain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetCertChain(ctx context.Context, in *GetCertChainRequest, opts ...grpc.CallOption) (*GetCertChainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCertChainResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetCertChain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetTLSCertificate(ctx context.Context, in *GetTLSCertificateRequest, opts ...grpc.CallOption) (*GetTLSCertificateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTLSCertificateResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetTLSCertificate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) GetImportParameters(ctx context.Context, in *GetImportParametersRequest, opts ...grpc.CallOption) (*GetImportParametersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetImportParametersResponse)
	err := c.cc.Invoke(ctx, KeystoreService_GetImportParameters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) WrapKey(ctx context.Context, in *WrapKeyRequest, opts ...grpc.CallOption) (*WrapKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WrapKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_WrapKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) UnwrapKey(ctx context.Context, in *UnwrapKeyRequest, opts ...grpc.CallOption) (*UnwrapKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnwrapKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_UnwrapKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ImportKey(ctx context.Context, in *ImportKeyRequest, opts ...grpc.CallOption) (*ImportKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ImportKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) ExportKey(ctx context.Context, in *ExportKeyRequest, opts ...grpc.CallOption) (*ExportKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_ExportKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) CopyKey(ctx context.Context, in *CopyKeyRequest, opts ...grpc.CallOption) (*CopyKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CopyKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_CopyKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostGenerateKey(ctx context.Context, in *FrostGenerateKeyRequest, opts ...grpc.CallOption) (*FrostGenerateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostGenerateKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostGenerateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostImportKey(ctx context.Context, in *FrostImportKeyRequest, opts ...grpc.CallOption) (*FrostImportKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostImportKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostImportKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostListKeys(ctx context.Context, in *FrostListKeysRequest, opts ...grpc.CallOption) (*FrostListKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostListKeysResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostListKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostGetKey(ctx context.Context, in *FrostGetKeyRequest, opts ...grpc.CallOption) (*FrostGetKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostGetKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostGetKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostDeleteKey(ctx context.Context, in *FrostDeleteKeyRequest, opts ...grpc.CallOption) (*FrostDeleteKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostDeleteKeyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostDeleteKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostGenerateNonces(ctx context.Context, in *FrostGenerateNoncesRequest, opts ...grpc.CallOption) (*FrostGenerateNoncesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostGenerateNoncesResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostGenerateNonces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostSignRound(ctx context.Context, in *FrostSignRoundRequest, opts ...grpc.CallOption) (*FrostSignRoundResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostSignRoundResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostSignRound_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostAggregate(ctx context.Context, in *FrostAggregateRequest, opts ...grpc.CallOption) (*FrostAggregateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostAggregateResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostAggregate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keystoreServiceClient) FrostVerify(ctx context.Context, in *FrostVerifyRequest, opts ...grpc.CallOption) (*FrostVerifyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FrostVerifyResponse)
	err := c.cc.Invoke(ctx, KeystoreService_FrostVerify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KeystoreServiceServer is the server API for KeystoreService service.
// All implementations must embed UnimplementedKeystoreServiceServer
// for forward compatibility.
//
// KeystoreService provides key management and cryptographic operations
type KeystoreServiceServer interface {
	// Health returns the health status of the service
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	// ListBackends returns all available backend providers
	ListBackends(context.Context, *ListBackendsRequest) (*ListBackendsResponse, error)
	// GetBackendInfo returns detailed information about a specific backend
	GetBackendInfo(context.Context, *GetBackendInfoRequest) (*GetBackendInfoResponse, error)
	// GenerateKey generates a new cryptographic key
	GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error)
	// ListKeys lists all keys in the specified backend
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
	// GetKey retrieves information about a specific key
	GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error)
	// Sign signs data with the specified key
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	// Verify verifies a signature with the specified key
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	// DeleteKey deletes a key from the backend
	DeleteKey(context.Context, *DeleteKeyRequest) (*DeleteKeyResponse, error)
	// RotateKey rotates an existing key
	RotateKey(context.Context, *RotateKeyRequest) (*RotateKeyResponse, error)
	// ListKeyVersions lists all versions of a key
	ListKeyVersions(context.Context, *ListKeyVersionsRequest) (*ListKeyVersionsResponse, error)
	// EnableKeyVersion enables a specific version of a key
	EnableKeyVersion(context.Context, *EnableKeyVersionRequest) (*EnableKeyVersionResponse, error)
	// DisableKeyVersion disables a specific version of a key
	DisableKeyVersion(context.Context, *DisableKeyVersionRequest) (*DisableKeyVersionResponse, error)
	// EnableAllKeyVersions enables all versions of a key
	EnableAllKeyVersions(context.Context, *EnableAllKeyVersionsRequest) (*EnableAllKeyVersionsResponse, error)
	// DisableAllKeyVersions disables all versions of a key
	DisableAllKeyVersions(context.Context, *DisableAllKeyVersionsRequest) (*DisableAllKeyVersionsResponse, error)
	// Encrypt encrypts data with the specified key (symmetric encryption)
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	// Decrypt decrypts data with the specified key
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	// EncryptAsym encrypts data using asymmetric encryption (RSA-OAEP)
	EncryptAsym(context.Context, *EncryptAsymRequest) (*EncryptAsymResponse, error)
	// SaveCert stores a certificate
	SaveCert(context.Context, *SaveCertRequest) (*SaveCertResponse, error)
	// GetCert retrieves a certificate
	GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error)
	// DeleteCert removes a certificate
	DeleteCert(context.Context, *DeleteCertRequest) (*DeleteCertResponse, error)
	// ListCerts lists all certificates
	ListCerts(context.Context, *ListCertsRequest) (*ListCertsResponse, error)
	// CertExists checks if a certificate exists
	CertExists(context.Context, *CertExistsRequest) (*CertExistsResponse, error)
	// SaveCertChain stores a certificate chain
	SaveCertChain(context.Context, *SaveCertChainRequest) (*SaveCertChainResponse, error)
	// GetCertChain retrieves a certificate chain
	GetCertChain(context.Context, *GetCertChainRequest) (*GetCertChainResponse, error)
	// GetTLSCertificate returns a TLS certificate with private key
	GetTLSCertificate(context.Context, *GetTLSCertificateRequest) (*GetTLSCertificateResponse, error)
	// GetImportParameters retrieves parameters needed to import a key
	GetImportParameters(context.Context, *GetImportParametersRequest) (*GetImportParametersResponse, error)
	// WrapKey wraps key material for secure transport
	WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error)
	// UnwrapKey unwraps previously wrapped key material
	UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error)
	// ImportKey imports externally generated key material into the backend
	ImportKey(context.Context, *ImportKeyRequest) (*ImportKeyResponse, error)
	// ExportKey exports a key in wrapped form for secure transport
	ExportKey(context.Context, *ExportKeyRequest) (*ExportKeyResponse, error)
	// CopyKey copies a key from one backend to another
	CopyKey(context.Context, *CopyKeyRequest) (*CopyKeyResponse, error)
	// FrostGenerateKey generates FROST key packages using trusted dealer model
	FrostGenerateKey(context.Context, *FrostGenerateKeyRequest) (*FrostGenerateKeyResponse, error)
	// FrostImportKey imports a FROST key package
	FrostImportKey(context.Context, *FrostImportKeyRequest) (*FrostImportKeyResponse, error)
	// FrostListKeys lists all FROST keys
	FrostListKeys(context.Context, *FrostListKeysRequest) (*FrostListKeysResponse, error)
	// FrostGetKey retrieves information about a specific FROST key
	FrostGetKey(context.Context, *FrostGetKeyRequest) (*FrostGetKeyResponse, error)
	// FrostDeleteKey deletes a FROST key
	FrostDeleteKey(context.Context, *FrostDeleteKeyRequest) (*FrostDeleteKeyResponse, error)
	// FrostGenerateNonces generates nonces and commitments for Round 1 of FROST signing
	FrostGenerateNonces(context.Context, *FrostGenerateNoncesRequest) (*FrostGenerateNoncesResponse, error)
	// FrostSignRound generates a signature share for Round 2 of FROST signing
	FrostSignRound(context.Context, *FrostSignRoundRequest) (*FrostSignRoundResponse, error)
	// FrostAggregate combines signature shares into a final FROST signature
	FrostAggregate(context.Context, *FrostAggregateRequest) (*FrostAggregateResponse, error)
	// FrostVerify verifies a FROST signature against the group public key
	FrostVerify(context.Context, *FrostVerifyRequest) (*FrostVerifyResponse, error)
	mustEmbedUnimplementedKeystoreServiceServer()
}

// UnimplementedKeystoreServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKeystoreServiceServer struct{}

func (UnimplementedKeystoreServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedKeystoreServiceServer) ListBackends(context.Context, *ListBackendsRequest) (*ListBackendsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListBackends not implemented")
}
func (UnimplementedKeystoreServiceServer) GetBackendInfo(context.Context, *GetBackendInfoRequest) (*GetBackendInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBackendInfo not implemented")
}
func (UnimplementedKeystoreServiceServer) GenerateKey(context.Context, *GenerateKeyRequest) (*GenerateKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateKey not implemented")
}
func (UnimplementedKeystoreServiceServer) ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListKeys not implemented")
}
func (UnimplementedKeystoreServiceServer) GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetKey not implemented")
}
func (UnimplementedKeystoreServiceServer) Sign(context.Context, *SignRequest) (*SignResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Sign not implemented")
}
func (UnimplementedKeystoreServiceServer) Verify(context.Context, *VerifyRequest) (*VerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedKeystoreServiceServer) DeleteKey(context.Context, *DeleteKeyRequest) (*DeleteKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteKey not implemented")
}
func (UnimplementedKeystoreServiceServer) RotateKey(context.Context, *RotateKeyRequest) (*RotateKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RotateKey not implemented")
}
func (UnimplementedKeystoreServiceServer) ListKeyVersions(context.Context, *ListKeyVersionsRequest) (*ListKeyVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListKeyVersions not implemented")
}
func (UnimplementedKeystoreServiceServer) EnableKeyVersion(context.Context, *EnableKeyVersionRequest) (*EnableKeyVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnableKeyVersion not implemented")
}
func (UnimplementedKeystoreServiceServer) DisableKeyVersion(context.Context, *DisableKeyVersionRequest) (*DisableKeyVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisableKeyVersion not implemented")
}
func (UnimplementedKeystoreServiceServer) EnableAllKeyVersions(context.Context, *EnableAllKeyVersionsRequest) (*EnableAllKeyVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnableAllKeyVersions not implemented")
}
func (UnimplementedKeystoreServiceServer) DisableAllKeyVersions(context.Context, *DisableAllKeyVersionsRequest) (*DisableAllKeyVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisableAllKeyVersions not implemented")
}
func (UnimplementedKeystoreServiceServer) Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedKeystoreServiceServer) Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedKeystoreServiceServer) EncryptAsym(context.Context, *EncryptAsymRequest) (*EncryptAsymResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EncryptAsym not implemented")
}
func (UnimplementedKeystoreServiceServer) SaveCert(context.Context, *SaveCertRequest) (*SaveCertResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveCert not implemented")
}
func (UnimplementedKeystoreServiceServer) GetCert(context.Context, *GetCertRequest) (*GetCertResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCert not implemented")
}
func (UnimplementedKeystoreServiceServer) DeleteCert(context.Context, *DeleteCertRequest) (*DeleteCertResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteCert not implemented")
}
func (UnimplementedKeystoreServiceServer) ListCerts(context.Context, *ListCertsRequest) (*ListCertsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCerts not implemented")
}
func (UnimplementedKeystoreServiceServer) CertExists(context.Context, *CertExistsRequest) (*CertExistsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CertExists not implemented")
}
func (UnimplementedKeystoreServiceServer) SaveCertChain(context.Context, *SaveCertChainRequest) (*SaveCertChainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveCertChain not implemented")
}
func (UnimplementedKeystoreServiceServer) GetCertChain(context.Context, *GetCertChainRequest) (*GetCertChainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCertChain not implemented")
}
func (UnimplementedKeystoreServiceServer) GetTLSCertificate(context.Context, *GetTLSCertificateRequest) (*GetTLSCertificateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTLSCertificate not implemented")
}
func (UnimplementedKeystoreServiceServer) GetImportParameters(context.Context, *GetImportParametersRequest) (*GetImportParametersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetImportParameters not implemented")
}
func (UnimplementedKeystoreServiceServer) WrapKey(context.Context, *WrapKeyRequest) (*WrapKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WrapKey not implemented")
}
func (UnimplementedKeystoreServiceServer) UnwrapKey(context.Context, *UnwrapKeyRequest) (*UnwrapKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnwrapKey not implemented")
}
func (UnimplementedKeystoreServiceServer) ImportKey(context.Context, *ImportKeyRequest) (*ImportKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImportKey not implemented")
}
func (UnimplementedKeystoreServiceServer) ExportKey(context.Context, *ExportKeyRequest) (*ExportKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExportKey not implemented")
}
func (UnimplementedKeystoreServiceServer) CopyKey(context.Context, *CopyKeyRequest) (*CopyKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CopyKey not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostGenerateKey(context.Context, *FrostGenerateKeyRequest) (*FrostGenerateKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostGenerateKey not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostImportKey(context.Context, *FrostImportKeyRequest) (*FrostImportKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostImportKey not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostListKeys(context.Context, *FrostListKeysRequest) (*FrostListKeysResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostListKeys not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostGetKey(context.Context, *FrostGetKeyRequest) (*FrostGetKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostGetKey not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostDeleteKey(context.Context, *FrostDeleteKeyRequest) (*FrostDeleteKeyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostDeleteKey not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostGenerateNonces(context.Context, *FrostGenerateNoncesRequest) (*FrostGenerateNoncesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostGenerateNonces not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostSignRound(context.Context, *FrostSignRoundRequest) (*FrostSignRoundResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostSignRound not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostAggregate(context.Context, *FrostAggregateRequest) (*FrostAggregateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostAggregate not implemented")
}
func (UnimplementedKeystoreServiceServer) FrostVerify(context.Context, *FrostVerifyRequest) (*FrostVerifyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FrostVerify not implemented")
}
func (UnimplementedKeystoreServiceServer) mustEmbedUnimplementedKeystoreServiceServer() {}
func (UnimplementedKeystoreServiceServer) testEmbeddedByValue()                         {}

// UnsafeKeystoreServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KeystoreServiceServer will
// result in compilation errors.
type UnsafeKeystoreServiceServer interface {
	mustEmbedUnimplementedKeystoreServiceServer()
}

func RegisterKeystoreServiceServer(s grpc.ServiceRegistrar, srv KeystoreServiceServer) {
	// If the following call panics, it indicates UnimplementedKeystoreServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KeystoreService_ServiceDesc, srv)
}

func _KeystoreService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ListBackends_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackendsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ListBackends(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ListBackends_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ListBackends(ctx, req.(*ListBackendsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetBackendInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackendInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetBackendInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetBackendInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetBackendInfo(ctx, req.(*GetBackendInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GenerateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GenerateKey(ctx, req.(*GenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ListKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ListKeys(ctx, req.(*ListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Sign_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_DeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).DeleteKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_DeleteKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).DeleteKey(ctx, req.(*DeleteKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_RotateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).RotateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_RotateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).RotateKey(ctx, req.(*RotateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ListKeyVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListKeyVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ListKeyVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ListKeyVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ListKeyVersions(ctx, req.(*ListKeyVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_EnableKeyVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableKeyVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).EnableKeyVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_EnableKeyVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).EnableKeyVersion(ctx, req.(*EnableKeyVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_DisableKeyVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableKeyVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).DisableKeyVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_DisableKeyVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).DisableKeyVersion(ctx, req.(*DisableKeyVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_EnableAllKeyVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableAllKeyVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).EnableAllKeyVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_EnableAllKeyVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).EnableAllKeyVersions(ctx, req.(*EnableAllKeyVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_DisableAllKeyVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableAllKeyVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).DisableAllKeyVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_DisableAllKeyVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).DisableAllKeyVersions(ctx, req.(*DisableAllKeyVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Encrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_Decrypt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_EncryptAsym_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptAsymRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).EncryptAsym(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_EncryptAsym_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).EncryptAsym(ctx, req.(*EncryptAsymRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_SaveCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).SaveCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_SaveCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).SaveCert(ctx, req.(*SaveCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetCert(ctx, req.(*GetCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_DeleteCert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).DeleteCert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_DeleteCert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).DeleteCert(ctx, req.(*DeleteCertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ListCerts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCertsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ListCerts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ListCerts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ListCerts(ctx, req.(*ListCertsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_CertExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).CertExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_CertExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).CertExists(ctx, req.(*CertExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_SaveCertChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveCertChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).SaveCertChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_SaveCertChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).SaveCertChain(ctx, req.(*SaveCertChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetCertChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCertChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetCertChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetCertChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetCertChain(ctx, req.(*GetCertChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetTLSCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTLSCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetTLSCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetTLSCertificate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetTLSCertificate(ctx, req.(*GetTLSCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_GetImportParameters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImportParametersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).GetImportParameters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_GetImportParameters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).GetImportParameters(ctx, req.(*GetImportParametersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_WrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).WrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_WrapKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).WrapKey(ctx, req.(*WrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_UnwrapKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnwrapKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).UnwrapKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_UnwrapKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).UnwrapKey(ctx, req.(*UnwrapKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ImportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ImportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ImportKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ImportKey(ctx, req.(*ImportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_ExportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).ExportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_ExportKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).ExportKey(ctx, req.(*ExportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_CopyKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).CopyKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_CopyKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).CopyKey(ctx, req.(*CopyKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostGenerateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostGenerateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostGenerateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostGenerateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostGenerateKey(ctx, req.(*FrostGenerateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostImportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostImportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostImportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostImportKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostImportKey(ctx, req.(*FrostImportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostListKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostListKeys(ctx, req.(*FrostListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostGetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostGetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostGetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostGetKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostGetKey(ctx, req.(*FrostGetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostDeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostDeleteKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostDeleteKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostDeleteKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostDeleteKey(ctx, req.(*FrostDeleteKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostGenerateNonces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostGenerateNoncesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostGenerateNonces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostGenerateNonces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostGenerateNonces(ctx, req.(*FrostGenerateNoncesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostSignRound_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostSignRoundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostSignRound(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostSignRound_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostSignRound(ctx, req.(*FrostSignRoundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostAggregate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostAggregateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostAggregate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostAggregate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostAggregate(ctx, req.(*FrostAggregateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KeystoreService_FrostVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrostVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeystoreServiceServer).FrostVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KeystoreService_FrostVerify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeystoreServiceServer).FrostVerify(ctx, req.(*FrostVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KeystoreService_ServiceDesc is the grpc.ServiceDesc for KeystoreService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KeystoreService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "keychain.v1.KeystoreService",
	HandlerType: (*KeystoreServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Health",
			Handler:    _KeystoreService_Health_Handler,
		},
		{
			MethodName: "ListBackends",
			Handler:    _KeystoreService_ListBackends_Handler,
		},
		{
			MethodName: "GetBackendInfo",
			Handler:    _KeystoreService_GetBackendInfo_Handler,
		},
		{
			MethodName: "GenerateKey",
			Handler:    _KeystoreService_GenerateKey_Handler,
		},
		{
			MethodName: "ListKeys",
			Handler:    _KeystoreService_ListKeys_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _KeystoreService_GetKey_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _KeystoreService_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _KeystoreService_Verify_Handler,
		},
		{
			MethodName: "DeleteKey",
			Handler:    _KeystoreService_DeleteKey_Handler,
		},
		{
			MethodName: "RotateKey",
			Handler:    _KeystoreService_RotateKey_Handler,
		},
		{
			MethodName: "ListKeyVersions",
			Handler:    _KeystoreService_ListKeyVersions_Handler,
		},
		{
			MethodName: "EnableKeyVersion",
			Handler:    _KeystoreService_EnableKeyVersion_Handler,
		},
		{
			MethodName: "DisableKeyVersion",
			Handler:    _KeystoreService_DisableKeyVersion_Handler,
		},
		{
			MethodName: "EnableAllKeyVersions",
			Handler:    _KeystoreService_EnableAllKeyVersions_Handler,
		},
		{
			MethodName: "DisableAllKeyVersions",
			Handler:    _KeystoreService_DisableAllKeyVersions_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _KeystoreService_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _KeystoreService_Decrypt_Handler,
		},
		{
			MethodName: "EncryptAsym",
			Handler:    _KeystoreService_EncryptAsym_Handler,
		},
		{
			MethodName: "SaveCert",
			Handler:    _KeystoreService_SaveCert_Handler,
		},
		{
			MethodName: "GetCert",
			Handler:    _KeystoreService_GetCert_Handler,
		},
		{
			MethodName: "DeleteCert",
			Handler:    _KeystoreService_DeleteCert_Handler,
		},
		{
			MethodName: "ListCerts",
			Handler:    _KeystoreService_ListCerts_Handler,
		},
		{
			MethodName: "CertExists",
			Handler:    _KeystoreService_CertExists_Handler,
		},
		{
			MethodName: "SaveCertChain",
			Handler:    _KeystoreService_SaveCertChain_Handler,
		},
		{
			MethodName: "GetCertChain",
			Handler:    _KeystoreService_GetCertChain_Handler,
		},
		{
			MethodName: "GetTLSCertificate",
			Handler:    _KeystoreService_GetTLSCertificate_Handler,
		},
		{
			MethodName: "GetImportParameters",
			Handler:    _KeystoreService_GetImportParameters_Handler,
		},
		{
			MethodName: "WrapKey",
			Handler:    _KeystoreService_WrapKey_Handler,
		},
		{
			MethodName: "UnwrapKey",
			Handler:    _KeystoreService_UnwrapKey_Handler,
		},
		{
			MethodName: "ImportKey",
			Handler:    _KeystoreService_ImportKey_Handler,
		},
		{
			MethodName: "ExportKey",
			Handler:    _KeystoreService_ExportKey_Handler,
		},
		{
			MethodName: "CopyKey",
			Handler:    _KeystoreService_CopyKey_Handler,
		},
		{
			MethodName: "FrostGenerateKey",
			Handler:    _KeystoreService_FrostGenerateKey_Handler,
		},
		{
			MethodName: "FrostImportKey",
			Handler:    _KeystoreService_FrostImportKey_Handler,
		},
		{
			MethodName: "FrostListKeys",
			Handler:    _KeystoreService_FrostListKeys_Handler,
		},
		{
			MethodName: "FrostGetKey",
			Handler:    _KeystoreService_FrostGetKey_Handler,
		},
		{
			MethodName: "FrostDeleteKey",
			Handler:    _KeystoreService_FrostDeleteKey_Handler,
		},
		{
			MethodName: "FrostGenerateNonces",
			Handler:    _KeystoreService_FrostGenerateNonces_Handler,
		},
		{
			MethodName: "FrostSignRound",
			Handler:    _KeystoreService_FrostSignRound_Handler,
		},
		{
			MethodName: "FrostAggregate",
			Handler:    _KeystoreService_FrostAggregate_Handler,
		},
		{
			MethodName: "FrostVerify",
			Handler:    _KeystoreService_FrostVerify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/proto/keychainv1/keychain.proto",
}
